}
med_me_de = matrix(data = NA, nrow = 2, ncol = 7)
for(i in 1:7){
med_me_de[1,i] = mean(medidas[,i])
med_me_de[2,i] = sd(medidas[,i])
}
return(med_me_de)
}
ba_05 = cal_alpaha_ba(500,.5)
ba_1 = cal_alpaha_ba(500,1)
ba_15 = cal_alpaha_ba(500,1.5)
ba_20 = cal_alpaha_ba(500,2)
ba_05
ba_1
f_second_moment(network)
f_degree(network)
c(f_degree(network))
medidas[1,6] = c(f_entropia(network))
medidas[1,1]
medidas[1,1] = 1
medidas[1,1] = c(1,2,3)
medidas[1,1] = list(c(1,2,3))
medidas[1,1]
list(c(1,2,3))
list(1,2,3)
mean(list(1,2,3))
list(c(1,2,3))
mean(list(c(1,2,3)))
mean(list(c(1,2,3))[0])
list(1,2,3)
mean(list(1,2,3))
medidas[1,1] =  1:2
medidas[1,1] =  1
vcount(network)
mean(vcount(network))
sd(500)
f_entropia(network)
mean(f_entropia(network))
mean_distance(network)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
f_degree <- function(G){
grau <- degree(G, mode = "all")
return (mean(grau))
}
f_second_moment <- function(G){
grau  = f_degree(G)
#Segundo Momento do Grau
grau <- grau^2
sum.grau.square = sum(grau)
total.grau <- length(grau)
kQuadrado <- sum.grau.square / total.grau
kQuadrado
return (mean(kQuadrado))
}
f_entropia <- function(G)
{
E(G)$weight <- runif(ecount(G))
e <- graph.diversity(G)
return(e)
}
cal_alpaha_ba <- function(n, alphaa){
medidas = matrix(data = NA, nrow = 30,ncol = 7)
for(i in 1:30){
network = sample_pa(n, alphaa)
medidas[i,1] = 1#f_degree(network)
medidas[i,2] = vcount(network)
medidas[i,3] = f_second_moment(network)
medidas[i,4] = transitivity(network)
medidas[i,5] = assortativity_degree(network)
medidas[i,6] = f_entropia(network)
medidas[i,7] = mean_distance(network)
}
med_me_de = matrix(data = NA, nrow = 2, ncol = 7)
for(i in 1:7){
med_me_de[1,i] = mean(medidas[,i])
med_me_de[2,i] = sd(medidas[,i])
}
return(med_me_de)
}
ba_05 = cal_alpaha_ba(500,.5)
ba_1 = cal_alpaha_ba(500,1)
ba_15 = cal_alpaha_ba(500,1.5)
ba_20 = cal_alpaha_ba(500,2)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
f_degree <- function(G){
grau <- degree(G, mode = "all")
return (mean(grau))
}
f_second_moment <- function(G){
grau  = f_degree(G)
#Segundo Momento do Grau
grau <- grau^2
sum.grau.square = sum(grau)
total.grau <- length(grau)
kQuadrado <- sum.grau.square / total.grau
kQuadrado
return (kQuadrado)
}
f_entropia <- function(G)
{
E(G)$weight <- runif(ecount(G))
e <- graph.diversity(G)
return (mean(e))
}
cal_alpaha_ba <- function(n, alphaa){
medidas = matrix(data = NA, nrow = 30,ncol = 7)
for(i in 1:30){
network = sample_pa(n, alphaa)
medidas[i,1] = 1#f_degree(network)
medidas[i,2] = vcount(network)
medidas[i,3] = f_second_moment(network)
medidas[i,4] = transitivity(network)
medidas[i,5] = assortativity_degree(network)
medidas[i,6] = f_entropia(network)
medidas[i,7] = mean_distance(network)
}
med_me_de = matrix(data = NA, nrow = 2, ncol = 7)
for(i in 1:7){
med_me_de[1,i] = mean(medidas[,i])
med_me_de[2,i] = sd(medidas[,i])
}
return(med_me_de)
}
ba_05 = cal_alpaha_ba(500,.5)
ba_1 = cal_alpaha_ba(500,1)
ba_15 = cal_alpaha_ba(500,1.5)
ba_20 = cal_alpaha_ba(500,2)
ba_05
ba_15
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,Size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,Size,col=3)
# Remoção com maior beetweenness
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,100)
Size<-rep(0,100)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,V(e)[which(be==max(be))])
}
plot(nos,Size,type = 'l',col=2,ylim = c(0,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,V(b)[which(be==max(be))])
}
lines(nos,Size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,Size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,Size,col=3)
# Remoção com maior beetweenness
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,100)
Size<-rep(0,100)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,V(e)[which(be==max(be))])
}
plot(nos,Size,type = 'l',col=2,ylim = c(0,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,V(b)[which(be==max(be))])
}
lines(nos,Size,col=3)
# Remoção com maior beetweenness
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,100)
Size<-rep(0,100)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,V(e)[which(be==max(be))])
}
plot(nos,Size,type = 'l',col=2,ylim = c(0,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,V(b)[which(be==max(be))])
}
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
Size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,Size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,Size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,Size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
Size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,Size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
Size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
require(igraph)
#
# 4	– Barabási-Albert	não-linear:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,type = 'l',col=2,ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
require(igraph)
#
# 5 – Falhas	e	ataques:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,
type = 'l',
col=2,
ylab = "Tamanho",
xlab = "Nós",
main = "Remoção Aletória",
ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
require(igraph)
#
# 5 – Falhas	e	ataques:
#
#Remoção Aleatória
e<-erdos.renyi.game(1000, 0.002, type = "gnp")
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
e_1 <- components(e)
size[i]<-max(e_1$csize)/sum(e_1$csize)
nos[i]<-i
e <- delete_edges(e,sample(E(e),1))
}
plot(nos,size,
type = 'l',
col=2,
ylab = "Tamanho",
xlab = "Vértices",
main = "Remoção Aletória",
ylim = c(0.6,1))
#Barabasi
b<- barabasi.game(1000,power = 1.2 ,m = NULL, out.dist = NULL, out.seq = NULL,
out.pref = FALSE, zero.appeal = 1, directed = FALSE,  algorithm ="psumtree", start.graph = NULL)
nos<-rep(0,10)
size<-rep(0,10)
for(i in 1:100){
b_1 <- components(b)
size[i]<-max(b_1$csize)/sum(b_1$csize)
nos[i]<-i
b <- delete_edges(b,sample(E(b),1))
}
lines(nos,size,col=3)
